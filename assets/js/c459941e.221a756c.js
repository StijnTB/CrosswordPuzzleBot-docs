"use strict";(globalThis.webpackChunkword_feud_bot_docs=globalThis.webpackChunkword_feud_bot_docs||[]).push([[1253],{285(e,t,r){r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"additional_information/code_summary/4trieclass","title":"trieclass.py","description":"The trieclass file defines the TRIE- and TRIENode-class. These classes are used to transform the main word list into a word tree for more efficient lookup times.","source":"@site/docs/additional_information/code_summary/4trieclass.md","sourceDirName":"additional_information/code_summary","slug":"/additional_information/code_summary/4trieclass","permalink":"/PWS-2526-CrosswordPuzzleBot/docs/additional_information/code_summary/4trieclass","draft":false,"unlisted":false,"editUrl":"https://github.com/StijnTB/CrosswordPuzzleBot-docs/tree/main/docs/additional_information/code_summary/4trieclass.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"trieclass.py","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"globals.py","permalink":"/PWS-2526-CrosswordPuzzleBot/docs/additional_information/code_summary/3globals"},"next":{"title":"tilebagclass.py","permalink":"/PWS-2526-CrosswordPuzzleBot/docs/additional_information/code_summary/5tilebagclass"}}');var s=r(4848),n=r(8453);const i={title:"trieclass.py",sidebar_position:4},a="trieclass.py",d={},l=[];function c(e){const t={em:"em",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"trieclasspy",children:"trieclass.py"})}),"\n",(0,s.jsx)(t.p,{children:"The trieclass file defines the TRIE- and TRIENode-class. These classes are used to transform the main word list into a word tree for more efficient lookup times."}),"\n",(0,s.jsx)(t.p,{children:"The TRIE-class is the wrapper for the word tree. It handles basic operations on the tree:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.em,{children:"insert(word: str)"}),": add ",(0,s.jsx)(t.em,{children:"word"})," to the tree."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.em,{children:"search_word(word: str)"}),": look up ",(0,s.jsx)(t.em,{children:"word"})," in the word tree. Returns ",(0,s.jsx)(t.em,{children:"True"})," if found and ",(0,s.jsx)(t.em,{children:"False"})," if not."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Every node in the word tree is a TRIENode. These nodes are linked to a letter and have a child node for every letter that can be put behind it, considering the ancestor nodes on the path between the root node and the current node. The Node has 2 properties:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.em,{children:"children"}),": returns a dictionary with every letter that can be put behind it as a key with the TRIENode linked to that letter on that position as the value."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.em,{children:"is_word"}),": A boolean which tells the program whether a string formed by the path between the root node and the current node is a valid word in the word list."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,t,r){r.d(t,{R:()=>i,x:()=>a});var o=r(6540);const s={},n=o.createContext(s);function i(e){const t=o.useContext(n);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);